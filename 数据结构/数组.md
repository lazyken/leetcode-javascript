> 本文主要参考《学习 Javascript 数据结构与算法》一书，并根据书中内容进行整理。推荐购买并阅读本书。  
> 人民邮电出版社  
> \[巴西\] Loiane Groner 著 孙晓博 邓岗 吴双 陈迪 袁源 译

# 数组

> 几乎所有编程语言都原生支持数组类型，JavaScript 也有数组类型。

# 创建和初始化数组

```js
var fruits = new Array(); // 使用构造函数生成空数组，返回 []
var fruits = new Array(3); // 使用构造函数生成长度为3的数组，返回 []
var fruits = new Array('apple', 'banana', 'orange');
// 使用构造函数生成长度为3的数组，返回 ['apple', 'banana', 'orange']
var fruits = ['apple', 'banana', 'orange'];
// 使用字面量形式直接生成数组
```

# 添加和删除元素

| 方法名                  | 描述                                                                              | 是否改变原数组 |
| ----------------------- | --------------------------------------------------------------------------------- | -------------- |
| Array.prototype.push    | 在原数组的末尾增加一个或多个元素，并返回数组的新长度。                            | 是             |
| Array.prototype.pop     | 删除原数组的最后一个元素，并返回这个元素。                                        | 是             |
| Array.prototype.shift   | 删除原数组的第一个元素，并返回这个元素。                                          | 是             |
| Array.prototype.unshift | 在原数组的开头增加一个或多个元素，并返回数组的新长度。                            | 是             |
| Array.prototype.splice  | 通过删除或替换现有元素或原地添加新的元素来修改数组,并以数组形式返回被修改的内容。 | 是             |

```js
array.splice(start[, deleteCount[, item1[, item2[, ...]]]])
```

> 通过 `push` 和 `pop` 方法，就能用数组来模拟栈。
> 通过 `shift` 和 `unshift` 方法，就能用数组模拟基本的队列数据结构。

# 二维和多维数组

二维数组就是数组中对元素也是数组

```js
// 二维数组，数组嵌套层数为2
// 2x3表示有2层嵌套，第一层有2个元素，第二层有3个元素
var matrix2x3 = [
  ['0-0', '0-1', '0-2'],
  ['1-0', '1-1', '1-2']
];
// 三维数组，数组嵌套层数为3
// 3x2x3表示有3层嵌套，第一层有3个元素，第二层有2个元素，第三层有3个元素
var matrix3x2x3 = [
  [
    ['0-0-0', '0-0-1', '0-0-2'],
    ['0-1-0', '0-1-1', '0-1-2']
  ],
  [
    ['1-0-0', '1-0-1', '1-0-2'],
    ['1-1-0', '1-1-1', '1-1-2']
  ],
  [
    ['2-0-0', '2-0-1', '2-0-2'],
    ['2-1-0', '2-1-1', '2-1-2']
  ]
];
// 多维数组依此类推
```

# 数组方法

> 数组对象有很多方法，[详见 MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array)

下面按照算法用途介绍数组的一些方法：

## 数组合并

**Array.prototype.concat()**
语法

> `var new_array = old_array.concat(value1[, value2[, ...[, valueN]]])`

```js
var a = [0];
var b = [4, 5, [6, 7], { d: 8 }];
var c = a.concat(1, 2, 3, b, { e: 9 });
// a => [0]
// b => [4, 5, [6, 7], { d: 8 }]
// c => [0, 1, 2, 3, 4, 5, [6, 7], { d: 8 }, { e: 9 }]
```

## 迭代器函数

### Array.prototype.every()

`every` 方法为数组中的每个元素执行一次 `callback` 函数，直到它找到一个会使 `callback` 返回 `falsy` 的元素。如果发现了一个这样的元素，`every` 方法将会立即返回 `false`。否则，`callback` 为每一个元素返回 `true`，`every` 就会返回 `true`。`callback` 只会为那些已经被赋值的索引调用。不会为那些被删除或从未被赋值的索引调用。

**语法**

> `arr.every(callback(element[, index[, array]])[, thisArg])`

**参数**

- `callback`：用来测试每个元素的函数，它可以接收三个参数：

  1. `element`：用于测试的当前值。
  2. `index`：用于测试的当前值的索引。
  3. `array`：调用 `every` 的当前数组。

- `thisArg`：指定执行 `callback` 时使用的 `this` 值。

**返回值**

- 如果回调函数的每一次返回都为 `truthy` 值，返回 `true` ，否则返回 `false`。

### Array.prototype.some()

`some() `为数组中的每一个元素执行一次 `callback` 函数，直到找到一个使得 `callback` 返回一个“真值”（即可转换为布尔值 `true` 的值）。如果找到了这样一个值，`some()` 将会立即返回 `true`。否则，`some()` 返回 `false`。`callback` 只会在那些”有值“的索引上被调用，不会在那些被删除或从来未被赋值的索引上调用。

**语法**

> `arr.some(callback(element[, index[, array]])[, thisArg])`

**参数**

- `callback`：用来测试每个元素的函数，它可以接收三个参数：

  1. `element`：用于测试的当前值。
  2. `index`：用于测试的当前值的索引。
  3. `array`：调用 `some` 的当前数组。

- `thisArg`：指定执行 `callback` 时使用的 `this` 值。

**返回值**

- 数组中有至少一个元素通过回调函数的测试就会返回 `true`；所有元素都没有通过回调函数的测试返回值才会为 `false`。

### 其他可以迭代数组的方法

`Array.prototype.forEach`、`Array.prototype.map`、`Array.prototype.filter`、`Array.prototype.reduce`

```js
var isEven = function (x) {
 // 如果x是2的倍数，就返回true
 console.log(x);
 return (x % 2 == 0) ? true : false;
 // 也可以写成return (x % 2 == 0) ? true : false
 };
 var
var numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15];

numbers.forEach(function (x) {
  console.log(x % 2 == 0);
  // 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15
});

var myMap = numbers.map(isEven);
// myMap => [false,true,false,true,false,true,false,true,false,true,false,true,false,true,false]

var evenNumbers = numbers.filter(isEven);
// evenNumbers =>  [2, 4, 6, 8, 10, 12, 14]

numbers.reduce(function (previous, current, index) {
  return previous + current; // 120
});

```

## 搜索和排序

### 排序

#### Array.prototype.reverse() 和 Array.prototype.sort()

```js
var numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15];
numbers.reverse();
// numbers => [15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1]
numbers.sort();
// numbers => [1, 10, 11, 12, 13, 14, 15, 2, 3, 4, 5, 6, 7, 8, 9]
numbers.sort(function (a, b) {
  return a - b;
});
// numbers => [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]
```

### 搜索

#### Array.prototype.indexOf()、Array.prototype.lastIndexOf()、Array.prototype.find()、Array.prototype.findIndex()、Array.prototype.includes()

```js
var numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15];
console.log(numbers.indexOf(10)); // 9
console.log(numbers.indexOf(100)); // -1

numbers.push(10);
console.log(numbers.lastIndexOf(10)); // 15,因为新增了10，它的下标是15
console.log(numbers.lastIndexOf(100)); // -1

numbers.find((n) => n > 5); // 6
numbers.find((n) => n > 20); // undefined
numbers.findIndex((n) => n > 5); // 5
numbers.findIndex((n) => n > 20); // -1

numbers.includes(5); // true
numbers.includes(20); // false
```

## 输出数组为字符串

### Array.prototype.toString()

`Array` 对象覆盖了 `Object` 的 `toString` 方法。对于数组对象，`toString` 方法连接数组并返回一个字符串，其中包含用逗号分隔的每个数组元素。  
当一个数组被作为文本值或者进行字符串连接操作时，将会自动调用其 `toString` 方法。

```js
var numbers = [1, 2, 3];
numbers.toString(); // '1,2,3'
```

### Array.prototype.join()

`arr.join([separator])`

所有的数组元素被转换成字符串，再用一个分隔符将这些字符串连接起来。

```js
var numbers = [1, 2, 3];
numbers.join('-'); // '1-2-3'
```
